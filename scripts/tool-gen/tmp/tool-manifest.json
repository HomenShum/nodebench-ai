{
  "toolName": "scan_terminal_security",
  "domain": "security",
  "targetFile": "securityTools.ts",
  "targetPath": "packages/mcp-local/src/tools/securityTools.ts",
  "isNewFile": false,
  "exportName": "securityTools",
  "toolObjectCode": "{\n    name: \"scan_terminal_security\",\n    description:\n      \"Scan project files and dev environment for terminal security threats: Unicode homograph attacks, ANSI escape injections, invisible characters, and suspicious URL patterns. Auto-discovers dotfiles, CI configs, env files, shell scripts, and package manifests. Inspired by github.com/HomenShum/terminal-security-scanner.\",\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        projectRoot: { type: \"string\", description: \"Project root directory to scan (default: cwd)\" },\n        scanHome: { type: \"boolean\", description: \"Also scan home directory dotfiles (default: false)\" },\n        checks: {\n          type: \"array\",\n          items: { type: \"string\", enum: [\"homograph\", \"ansi\", \"urls\", \"all\"] },\n          description: \"Which checks to run (default: ['all'])\",\n        },\n        verbose: { type: \"boolean\", description: \"Include line-level details in output (default: false)\" },\n      },\n    },\n    handler: async (args: { projectRoot?: string; scanHome?: boolean; checks?: string[]; verbose?: boolean }) => {\n      const root = args.projectRoot || process.cwd();\n      const homeDir = process.env.HOME || process.env.USERPROFILE || \"\";\n      let checks = args.checks ?? [\"all\"];\n      if (checks.includes(\"all\")) checks = [\"homograph\", \"ansi\", \"urls\"];\n\n      // File discovery patterns\n      const projectGlobs = [\n        \".env\", \".env.local\", \".env.production\", \".env.development\",\n        \"Makefile\", \"Dockerfile\", \"Jenkinsfile\",\n        \"package.json\", \"tsconfig.json\",\n      ];\n      const projectDirGlobs = [\n        { dir: \".github/workflows\", ext: \".yml\" },\n        { dir: \".github/workflows\", ext: \".yaml\" },\n      ];\n      const homeFiles = [\n        \".bashrc\", \".zshrc\", \".bash_profile\", \".profile\",\n        \".gitconfig\", \".npmrc\",\n      ];\n      const shellScriptExts = [\".sh\", \".bash\", \".zsh\"];\n\n      const filesToScan: Array<{ filePath: string; category: string }> = [];\n\n      // Discover project files\n      for (const f of projectGlobs) {\n        const fp = path.join(root, f);\n        try { if (fs.statSync(fp).isFile()) filesToScan.push({ filePath: fp, category: \"config\" }); } catch {}\n      }\n\n      // Discover CI workflow files\n      for (const dg of projectDirGlobs) {\n        const dir = path.join(root, dg.dir);\n        try {\n          if (fs.statSync(dir).isDirectory()) {\n            for (const f of fs.readdirSync(dir)) {\n              if (f.endsWith(dg.ext)) filesToScan.push({ filePath: path.join(dir, f), category: \"ci\" });\n            }\n          }\n        } catch {}\n      }\n\n      // Discover shell scripts in project root\n      try {\n        for (const f of fs.readdirSync(root)) {\n          if (shellScriptExts.some((ext) => f.endsWith(ext))) {\n            filesToScan.push({ filePath: path.join(root, f), category: \"script\" });\n          }\n        }\n      } catch {}\n\n      // Optionally scan home directory\n      if (args.scanHome && homeDir) {\n        for (const f of homeFiles) {\n          const fp = path.join(homeDir, f);\n          try { if (fs.statSync(fp).isFile()) filesToScan.push({ filePath: fp, category: \"dotfile\" }); } catch {}\n        }\n      }\n\n      // Scan each file\n      const fileResults: Array<{\n        file: string;\n        category: string;\n        findings: number;\n        highSeverity: number;\n        details: Array<{ severity: string; line: number; description: string }> | string;\n      }> = [];\n      let totalFindings = 0;\n      let totalHigh = 0;\n\n      for (const entry of filesToScan) {\n        let content: string;\n        try { content = fs.readFileSync(entry.filePath, \"utf-8\"); } catch { continue; }\n\n        const findings = analyzeCode(content, checks);\n        const highCount = findings.filter((f) => f.severity === \"HIGH\").length;\n        totalFindings += findings.length;\n        totalHigh += highCount;\n\n        if (findings.length > 0 || args.verbose) {\n          fileResults.push({\n            file: entry.filePath,\n            category: entry.category,\n            findings: findings.length,\n            highSeverity: highCount,\n            details: args.verbose\n              ? findings.map((f) => ({ severity: f.severity, line: f.line, description: f.description }))\n              : findings.length > 0 ? `${findings.length} finding(s) â€” use verbose:true for details` : \"clean\",\n          });\n        }\n      }\n\n      return {\n        projectRoot: root,\n        filesScanned: filesToScan.length,\n        filesWithFindings: fileResults.filter((r) => r.findings > 0).length,\n        totalFindings,\n        highSeverity: totalHigh,\n        checksRun: checks,\n        scanTargets: {\n          config: filesToScan.filter((f) => f.category === \"config\").length,\n          ci: filesToScan.filter((f) => f.category === \"ci\").length,\n          script: filesToScan.filter((f) => f.category === \"script\").length,\n          dotfile: filesToScan.filter((f) => f.category === \"dotfile\").length,\n        },\n        results: fileResults,\n        summary: totalFindings === 0\n          ? `Scanned ${filesToScan.length} files. No terminal security threats detected.`\n          : `Scanned ${filesToScan.length} files. Found ${totalFindings} issues (${totalHigh} HIGH). Review results for homograph attacks, ANSI injections, and suspicious URLs.`,\n      };\n    },\n  }",
  "needsNewImports": "",
  "testCode": "describe(\"Static: scan_terminal_security tool\", () => {\n  const tool = domainTools.find((t) => t.name === \"scan_terminal_security\");\n  it(\"should exist\", () => {\n    expect(tool).toBeDefined();\n  });\n  it(\"should accept projectRoot and checks\", () => {\n    const props = tool!.inputSchema.properties as Record<string, unknown>;\n    expect(props).toHaveProperty(\"projectRoot\");\n    expect(props).toHaveProperty(\"checks\");\n  });\n  it(\"should accept scanHome and verbose flags\", () => {\n    const props = tool!.inputSchema.properties as Record<string, unknown>;\n    expect(props).toHaveProperty(\"scanHome\");\n    expect(props).toHaveProperty(\"verbose\");\n  });\n});",
  "categoryMapEntry": {
    "security": [
      "scan_terminal_security"
    ]
  },
  "toolNames": [
    "scan_terminal_security"
  ]
}
